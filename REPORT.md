# Параллелизм и асинхронность
## IO-bound. Проверяем ссылки на страницах Википедии
### синхронно в 1 поток:

Время выполнения:

![image](1.bmp)
Заняло около 22 минут

Диспетчер задач:

![image](2.bmp)


### С помощью ThreadPoolExecutor:
*  5 воркеров

Время выполнения:

![image](3.bmp)
Около 5 минут

Диспетчер задач:

![image](4.bmp)

* 10 воркеров:

Время выполнения:

![image](5.bmp)
около 4 минут

Диспетчер задач:

![image](6.bmp)

* 100 воркеров:

Время выполнения:

![image](7.bmp)
около 3 минут

Диспетчер задач:

![image](8.bmp)

### Вывод:
Использование памяти значительно разнится в сравнение с одним потоком, если сравнивать с разными значениями(5, 10, 100), то разница практически не заметна. При использовании ThreadPoolExecutor уменьшилось время выполнения.

## CPU-bound. Генерируем монетки

* На 1 ядре:

Время выполнения:

![image](9.bmp)
около 2 минут

Диспетчер задач:

![image](10.bmp)

* 2 воркера:

Время выполнения:

![image](11.bmp)
около 2 минут

Диспетчер задач:

![image](12.bmp)

* 4 воркера:

Время выполнения:

![image](13.bmp)
около 2 минут

Диспетчер задач:

![image](14.bmp)

* 5 воркеров:

Время выполнения:

![image](15.bmp)
меньше минуты

Диспетчер задач:

![image](16.bmp)

* 10 воркеров:

Время выполнения:

![image](17.bmp)
около минуты

Диспетчер задач:

![image](18.bmp)

* 100 воркеров:
* ошибка

![image](19.bmp)

### Вывод:
При использовании одного ядра нагрузка была несильной. При использовании ProcessPoolExecutor время сократилось. При увеличении воркеров нагрузка на ЦП немного увеличивалась. Есть некоторая погрешность в значениях, так как нагрузка была неоднозначной.
